/**
 * Global CSS Injector
 *
 * When CSS source maps are not available, the captured CSS bundles cannot be
 * matched to individual CSS module stubs (because bundling merges all modules
 * into a single file, losing the original file boundaries).
 *
 * This module provides a fallback: inject the captured CSS bundles as global
 * stylesheets by:
 * 1. Creating a `_captured-styles.css` file that imports all captured bundles
 * 2. Injecting an import of this file into the detected entry point
 *
 * This ensures the rebuilt application has all the original styles, even though
 * CSS module boundaries are lost.
 */

import { readFile, writeFile } from 'fs/promises';
import { join, dirname, relative } from 'path';
import { toPosixPath } from '@web2local/utils';
import type { CapturedCssBundle } from '@web2local/stubs';
import type { EntryPoint } from './types.js';

/**
 * Result from global CSS injection
 */
export interface GlobalCssInjectionResult {
    /** Whether injection was performed */
    injected: boolean;
    /** Path to the generated _captured-styles.css file (relative to project) */
    capturedStylesPath?: string;
    /** Entry point that was modified */
    modifiedEntryPoint?: string;
    /** CSS bundles that were included */
    includedBundles: string[];
    /** Any errors encountered */
    errors: string[];
}

/**
 * Options for global CSS injection
 */
export interface GlobalCssInjectionOptions {
    /** Project root directory */
    projectDir: string;
    /** Captured CSS bundles that weren't matched to stubs */
    unusedBundles: CapturedCssBundle[];
    /** Detected entry points */
    entryPoints: EntryPoint[];
    /** Progress callback */
    onProgress?: (message: string) => void;
}

/**
 * Generates the content for _captured-styles.css
 */
export function generateCapturedStylesContent(
    bundles: CapturedCssBundle[],
    projectDir: string,
    capturedStylesDir: string,
): string {
    const lines: string[] = [
        '/**',
        ' * Auto-generated: Imports captured CSS bundles',
        ' *',
        ' * CSS source maps were not available, so the original CSS module files',
        ' * could not be recovered. This file imports the bundled CSS to ensure',
        ' * styles are applied to the rebuilt application.',
        ' *',
        ' * Generated by web2local-node',
        ' */',
        '',
    ];

    // Calculate relative paths from _captured-styles.css location to each bundle
    for (const bundle of bundles) {
        const bundleFullPath = join(
            projectDir,
            '_server',
            'static',
            bundle.localPath,
        );
        const relativePath = toPosixPath(
            relative(capturedStylesDir, bundleFullPath),
        );
        lines.push(`/* Bundle: ${bundle.filename} */`);
        lines.push(`@import '${relativePath}';`);
        lines.push('');
    }

    return lines.join('\n');
}

/**
 * Injects a CSS import at the top of a source file.
 * Handles both ESM and CommonJS style files.
 */
export function injectCssImport(
    sourceContent: string,
    cssImportPath: string,
): string {
    const importStatement = `import '${cssImportPath}'; // Auto-injected: captured CSS bundles (source maps unavailable)\n`;

    // Find the best insertion point:
    // 1. After any "use strict" or hashbang
    // 2. After existing imports (to group with them)
    // 3. At the top of the file

    const lines = sourceContent.split('\n');
    let insertIndex = 0;

    // Skip hashbang if present
    if (lines[0]?.startsWith('#!')) {
        insertIndex = 1;
    }

    // Skip "use strict" if present
    if (lines[insertIndex]?.trim().match(/^["']use strict["'];?$/)) {
        insertIndex++;
    }

    // Skip empty lines after hashbang/use strict
    while (insertIndex < lines.length && lines[insertIndex].trim() === '') {
        insertIndex++;
    }

    // Check if there are existing imports - if so, add after the last import block
    let lastImportIndex = -1;
    let inImportBlock = false;

    for (let i = insertIndex; i < lines.length; i++) {
        const line = lines[i].trim();

        // Check for import statements
        if (
            line.startsWith('import ') ||
            line.startsWith('import{') ||
            line.match(/^import\s*\(/) || // dynamic import
            (inImportBlock && (line === '' || line.startsWith('}'))) // multi-line import continuation
        ) {
            lastImportIndex = i;
            inImportBlock = line.includes('{') && !line.includes('}');
        }
        // Check for require statements at top level
        else if (line.match(/^(const|let|var)\s+\w+\s*=\s*require\(/)) {
            lastImportIndex = i;
        }
        // Stop when we hit non-import code
        else if (
            line !== '' &&
            !line.startsWith('//') &&
            !line.startsWith('/*')
        ) {
            break;
        }
    }

    // Insert after imports if found, otherwise at the calculated position
    if (lastImportIndex >= 0) {
        insertIndex = lastImportIndex + 1;

        // Add a blank line before our import if the previous line isn't blank
        if (lines[insertIndex - 1]?.trim() !== '') {
            lines.splice(insertIndex, 0, '');
            insertIndex++;
        }
    }

    // Insert the import
    lines.splice(insertIndex, 0, importStatement);

    return lines.join('\n');
}

/**
 * Injects captured CSS bundles as global styles.
 *
 * This is used as a fallback when CSS source maps are not available.
 * It creates a _captured-styles.css file that imports all captured bundles,
 * then injects an import of this file into the entry point.
 */
export async function injectGlobalCss(
    options: GlobalCssInjectionOptions,
): Promise<GlobalCssInjectionResult> {
    const { projectDir, unusedBundles, entryPoints, onProgress } = options;

    const result: GlobalCssInjectionResult = {
        injected: false,
        includedBundles: [],
        errors: [],
    };

    // Nothing to inject if no unused bundles
    if (unusedBundles.length === 0) {
        onProgress?.('No unused CSS bundles to inject');
        return result;
    }

    // Need at least one entry point to inject into
    if (entryPoints.length === 0) {
        result.errors.push(
            'No entry points detected - cannot inject global CSS',
        );
        return result;
    }

    // Use the primary (highest confidence) entry point
    const primaryEntry = entryPoints[0];
    const entryPath = join(projectDir, primaryEntry.path);

    onProgress?.(
        `Preparing to inject ${unusedBundles.length} CSS bundles into ${primaryEntry.path}`,
    );

    // Create _captured-styles.css in the project root
    const capturedStylesPath = join(projectDir, '_captured-styles.css');
    const capturedStylesDir = dirname(capturedStylesPath);

    try {
        // Generate the captured styles content
        const capturedStylesContent = generateCapturedStylesContent(
            unusedBundles,
            projectDir,
            capturedStylesDir,
        );

        // Write the _captured-styles.css file
        await writeFile(capturedStylesPath, capturedStylesContent, 'utf-8');
        onProgress?.(`Created ${relative(projectDir, capturedStylesPath)}`);

        result.capturedStylesPath = '_captured-styles.css';
        result.includedBundles = unusedBundles.map((b) => b.filename);

        // Read the entry point
        let entryContent: string;
        try {
            entryContent = await readFile(entryPath, 'utf-8');
        } catch (error) {
            result.errors.push(
                `Failed to read entry point ${primaryEntry.path}: ${error}`,
            );
            return result;
        }

        // Check if already injected
        if (entryContent.includes('_captured-styles.css')) {
            onProgress?.('Global CSS import already present in entry point');
            result.injected = true;
            result.modifiedEntryPoint = primaryEntry.path;
            return result;
        }

        // Calculate relative path from entry point to _captured-styles.css
        const entryDir = dirname(entryPath);
        let relativeCssPath = relative(entryDir, capturedStylesPath);

        // Ensure it starts with ./ for relative imports
        if (
            !relativeCssPath.startsWith('.') &&
            !relativeCssPath.startsWith('/')
        ) {
            relativeCssPath = './' + relativeCssPath;
        }

        // Normalize path separators for imports
        relativeCssPath = relativeCssPath.replace(/\\/g, '/');

        // Inject the import
        const modifiedContent = injectCssImport(entryContent, relativeCssPath);

        // Write the modified entry point
        await writeFile(entryPath, modifiedContent, 'utf-8');
        onProgress?.(`Injected CSS import into ${primaryEntry.path}`);

        result.injected = true;
        result.modifiedEntryPoint = primaryEntry.path;
    } catch (error) {
        result.errors.push(`Failed to inject global CSS: ${error}`);
    }

    return result;
}

/**
 * Checks if global CSS injection is needed.
 *
 * Returns true if:
 * - There are CSS stubs that weren't matched to captured bundles
 * - There are captured CSS bundles that weren't used
 * - The unused bundles are significant (not just tiny utility files)
 */
export function needsGlobalCssInjection(
    unmatchedStubs: string[],
    unusedBundles: CapturedCssBundle[],
    minBundleSize: number = 1000, // Minimum 1KB to be considered significant
): boolean {
    // If there are unmatched stubs and unused bundles of significant size
    if (unmatchedStubs.length > 0 && unusedBundles.length > 0) {
        // Check if any unused bundle is significant
        const hasSignificantBundle = unusedBundles.some(
            (bundle) => bundle.content.length >= minBundleSize,
        );
        return hasSignificantBundle;
    }

    return false;
}
